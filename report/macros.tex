\newcounter{statementcounter}
\newtheorem{definition}[statementcounter]{Definition}
\newtheorem{lemma}[statementcounter]{Lemma}
\newtheorem{theorem}[statementcounter]{Theorem}

\newenvironment{judgement}[2]{
\vspace{0.5cm}
\noindent \framebox{#1} (#2)
\vspace{0.5cm}
}{
\vspace{0.5cm}
}

% previously just did:

%{ % judgement
%\vspace{0.5cm}
%\noindent \framebox{thejudgement}
%
%\begin{prooftree}
%  some rule
%\end{prooftree}
%
%\vspace{0.5cm}
%}

\newenvironment{proof}[1][Proof]{
\paragraph{#1}
}{
\begin{flushright}
$\blacksquare$
\end{flushright}
}

% meta
\newcommand{\ensurecommand}[1]{\providecommand{#1}{}\renewcommand{#1}}
\ensurecommand{\comment}[1]{}

% judgements/rules
\ensurecommand{\ninf}[1]{\AxiomC{#1}}
\ensurecommand{\uinf}[1]{\UnaryInfC{#1}}
\ensurecommand{\binf}[1]{\BinaryInfC{#1}}
\ensurecommand{\tinf}[1]{\TrinaryInfC{#1}}
\ensurecommand{\qinf}[1]{\QuaternaryInfC{#1}}
\ensurecommand{\ax}[1]{\ninf{} \uinf{#1}}
\ensurecommand{\prem}[2]{\noLine \ninf{$#1$} \uinf{#2}}
\ensurecommand{\leftl}[1]{\LeftLabel{#1 \;}}
\ensurecommand{\rightl}[1]{\RightLabel{#1}}
\ensurecommand{\rulename}{\textsc}

% symbols
\ensurecommand{\sig}{\Sigma}
\ensurecommand{\ctx}{\Gamma}
\ensurecommand{\ctxvar}{\Delta}
\ensurecommand{\ctxvarvar}{\Xi}
\ensurecommand{\E}{\mathcal{E}}
\ensurecommand{\T}{\mathcal{T}}
\ensurecommand{\I}{\mathcal{I}}
\ensurecommand{\K}{\mathcal{K}}
\ensurecommand{\P}{\mathcal{P}}
\ensurecommand{\S}{\mathcal{S}}
\ensurecommand{\M}{\mathcal{M}}

% misc/general
\ensurecommand{\ldots}{...}
\ensurecommand{\defi}{\Coloneqq}
\ensurecommand{\mdefi}{\coloneqq} % mathematical definition, as opposed to syntactical categories (\defi)
\ensurecommand{\alt}{\;\; | \;\;}
\ensurecommand{\|}{\; | \;}
\ensurecommand{\set}[1]{\{ #1 \}}
\ensurecommand{\tup}[1]{\langle #1 \rangle}
\ensurecommand{\nil}{\cdot}
\ensurecommand{\FV}[1]{\mathsf{FV}(#1)}
\ensurecommand{\dom}[1]{\mathsf{dom}(#1)}

% abstract substitution
\ensurecommand{\abssub}{\theta}
\ensurecommand{\abssubvar}{\vartheta}
\ensurecommand{\U}{\mathcal{U}}
\ensurecommand{\supp}[1]{\mathsf{supp}(#1)}
\ensurecommand{\vran}[1]{\mathsf{vran}(#1)}
\ensurecommand{\mgu}[1]{\mathsf{mgu}(#1)}
\ensurecommand{\for}[2]{#1 / #2}
\ensurecommand{\restr}[2]{#1|_{#2}}

% concrete substitution
\ensurecommand{\sub}{\sigma}
\ensurecommand{\subvar}{\tau}
\ensurecommand{\emptysub}{\varepsilon}
\ensurecommand{\idsub}{\mathsf{id}}
\ensurecommand{\comp}[2]{#1 \circ #2}

% unification
\ensurecommand{\ueqn}[2]{#1 \mathrel{\dot{=}} #2}
\ensurecommand{\ustate}{\Psi}
\ensurecommand{\ustep}[2]{\ensuremath{#1 \Longrightarrow #2}}
\ensurecommand{\usteps}[2]{\ensuremath{#1 \Longrightarrow^* #2}}

% lf syntax
\ensurecommand{\type}{\mathtt{type}}
\ensurecommand{\pi}[2]{\Pi \, #1 . \, #2} % previously {\Pi \; #1 \, . \; #2}
\ensurecommand{\app}[2]{#1 \; #2}
\ensurecommand{\typing}[2]{#1 {:} #2} % equivalently, \mathord{:}

% lf judgements
\ensurecommand{\hasType}[3]{\ensuremath{#1 \vdash_{\sig} #2 : #3}}
\ensurecommand{\hasKind}[3]{\ensuremath{#1 \vdash_{\sig} #2 : #3}}
\ensurecommand{\isType}[2]{\ensuremath{#1 \vdash_{\sig} #2 \; \mathbf{type}}}
\ensurecommand{\isKind}[2]{\ensuremath{#1 \vdash_{\sig} #2 \; \mathbf{kind}}}
\ensurecommand{\isSig}[1]{\ensuremath{\vdash #1 \; \mathbf{sig}}}
\ensurecommand{\isCtx}[1]{\ensuremath{\vdash_{\sig} #1 \; \mathbf{ctx}}}
\ensurecommand{\subHasCtx}[3]{\ensuremath{#1 \vdash_{\sig} #2 : #3}}
% consider, using search-and-replace, to make all hasKind use hasType and isKind use isType

% coverage
\ensurecommand{\triple}[3]{\tup{#1, #2, #3}}
\ensurecommand{\goal}[3]{\tup{#1, #2, #3}}

% inhabitation judgements
\ensurecommand{\unifiable}[3]{\ensuremath{\vdash \mathbf{unifiable} \; #1 \; #2 \; \Rightarrow #3}}
\ensurecommand{\isSim}[6]{\ensuremath{#1 \ctxsep #2 \; \vdash_{\sig} #3 \sim #4 : \tup{#5 \tupsep #6}}}
\ensurecommand{\coops}[4]{\ensuremath{#1 \ctxsep #2 \; \vdash_{\sig} #3 \; \mathbf{coops} \; #4}}
\ensurecommand{\anyEmpty}[2]{\ensuremath{#1 \vdash_{\sig} #2 \; \mathbf{empty}}}
\ensurecommand{\allCoops}[4]{\ensuremath{#1 \ctxsep #2 \; \vdash_{\sig} #3 \; \mathbf{coops} \; #4}}
\ensurecommand{\isEmpty}[3]{\ensuremath{#1 \ctxsep #2 \; \vdash_{\sig} #3 \; \mathbf{empty}}}

% operational semantics
\ensurecommand{\conj}[2]{#1 \wedge #2}
\ensurecommand{\isGoal}[2]{\ensuremath{#1 \vdash_{\sig} #2 \; \mathbf{goal}}}
\ensurecommand{\isClause}[1]{\ensuremath{\vdash_{\sig} #1 \; \mathbf{clause}}}
\ensurecommand{\isProg}[1]{\ensuremath{\vdash_{\sig} #1 \; \mathbf{prog}}}
\ensurecommand{\solveGoal}[3]{\ensuremath{#1 \vdash_{D} #2 \| #3}}
\ensurecommand{\mguParts}[3]{\ensuremath{\mgu{#1} \rightarrow \tup{#2, #3}}}

% mode checking
\ensurecommand{\+}{\texttt{+}}
\ensurecommand{\-}{\texttt{-}}
\ensurecommand{\*}{\texttt{*}}
\ensurecommand{\msig}{\mu}
\ensurecommand{\appterm}{\psi}
\ensurecommand{\appsub}{\Psi}
\ensurecommand{\unk}{\mathtt{unk}}
\ensurecommand{\gnd}{\mathtt{gnd}}
\ensurecommand{\appsubMatch}[2]{\ensuremath{\vdash #1 : #2}}

\ensurecommand{\mcheckIn}[2]{\ensuremath{#1 \vdash_{\msig}^{\+} #2}}
\ensurecommand{\maddIn}[3]{\ensuremath{#1 \vdash_{\msig}^{\+} #2 > #3}}
\ensurecommand{\mcheckOut}[2]{\ensuremath{#1 \vdash_{\msig}^{\-} #2}}
\ensurecommand{\maddOut}[3]{\ensuremath{#1 \vdash_{\msig}^{\-} #2 > #3}}

\ensurecommand{\mcheckGoal}[3]{\ensuremath{#1 \vdash_{\msig} #2 > #3}}
\ensurecommand{\mcheckClause}[1]{\ensuremath{\vdash_{\msig} #1 \; \mathbf{mcorr}}}
\ensurecommand{\mcheckProg}[1]{\ensuremath{\vdash_{\msig} #1 \; \mathbf{mcorr}}}

\ensurecommand{\approx}{\prec}

%%% end
