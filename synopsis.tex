\documentclass[12pt]{article}

\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx}

\usepackage{amsmath, amssymb}
\usepackage{mathtools}

\usepackage{bussproofs}

\newcommand{\ensurecommand}[1]{\providecommand{#1}{}\renewcommand{#1}}

\ensurecommand{\defi}{\Coloneqq}
\ensurecommand{\alt}{\;\; | \;\;}
\ensurecommand{\eval}[2]{\ensuremath{#1 \downarrow #2}}
\ensurecommand{\step}[2]{\ensuremath{#1 \rightarrow #2}}

\ensurecommand{\true}{\mathtt{true}}
\ensurecommand{\false}{\mathtt{false}}

\ensurecommand{\ninf}[1]{\AxiomC{#1}}
\ensurecommand{\uinf}[1]{\UnaryInfC{#1}}
\ensurecommand{\binf}[1]{\BinaryInfC{#1}}
\ensurecommand{\ax}[1]{\ninf{} \uinf{#1}}
\ensurecommand{\leftl}[1]{\LeftLabel{#1 \;}}
\ensurecommand{\rulename}{\textsc}

\begin{document}

\title{Synopsis: Output Coverage in Twelf}
\author{Jannik Gram}
\date{February 9, 2016}

\maketitle

\section*{Background}

In logic programming, functions are expressed as relations. [...]
% And some relations are in fact total functions..

[How this relates to LF and Twelf.]

As part of the abstract syntax of a programming language, it is common to have truth values $t$ and boolean expressions $b$:
\begin{align*}
  t &\defi \true \alt \false \\
  b &\defi t \alt \neg{b} \alt \cdots
\end{align*}
And the following evaluation judgement gives a natural semantics to boolean expressions:

{ % judgement
\vspace{0.5cm}
\noindent \framebox{\eval{b}{t}}

\begin{prooftree}
  \leftl{\rulename{E-Const} :}
  \ax{\eval{t}{t}}
\end{prooftree}

\begin{prooftree}
  \ninf{\eval{b}{\true}}
  \leftl{\rulename{E-NegT} :}
  \uinf{\eval{\neg{b}}{\false}}
\end{prooftree}

\begin{prooftree}
  \ninf{\eval{b}{\false}}
  \leftl{\rulename{E-NegF} :}
  \uinf{\eval{\neg{b}}{\true}}
\end{prooftree}

\centering{$\vdots$}

\vspace{0.5cm}
}

This relation (as far as it is specified) is clearly a function, viewing $b$ as input and $t$ as output.
It is furthermore a total function, i.e. any expression $b$ evaluates to some value $t$.
If we omit one of the rules for negation, however, the function is no longer total;
the premise of the remaining rule requires that $b$ evaluates to a specific truth value, but that is by no means a certainty.

In terms of logic programming, the output of a subgoal is not [what is correct to say?]
% it checks that the output of each premise of each constant can never fail to unify with an output that is actually produced.
This is the notion of \textit{output coverage}.

\section*{Problem}

If we formalise the relation above in e.g. LF, we might then like the Twelf system to be able to verify that it defines a total function.
However, as part of its totality checker Twelf checks output coverage --- and it does so for each rule in isolation.
This way it correctly identifies that the version with just a single of the above rules for negation does not define a total function.
On the other hand, it fails to identify that \rulename{E-NegT} and \rulename{E-NegF} together make the function total.
% That is, we are prevented from pattern matching on the output

The typical way around this problem in Twelf is to turn an output-coverage checking problem into an input-coverage checking problem.
That is, we essentially have to write a single general \rulename{E-Neg} rule that then uses an auxiliary negation judgement:

\begin{prooftree}
  \ninf{\eval{b}{t}}
  \ninf{\step{t}{t'}}
  \leftl{\rulename{E-Neg} :}
  \binf{\eval{\neg{b}}{t'}}
\end{prooftree}

{ % judgement
\vspace{0.5cm}
\noindent \framebox{\step{t}{t'}}

\begin{prooftree}
  \leftl{\rulename{N-True} :}
  \ax{\step{\true}{\false}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{N-False} :}
  \ax{\step{\false}{\true}}
\end{prooftree}

\vspace{0.5cm}
}

Twelf will then be able to verify that the evaluation relation is a total function, but this comes at the cost of readability and extra work.
The problem is particularly present when proving meta-theorems about deductive systems and using totality checking as proof checking, which is after all what Twelf is designed for.
% i.e. lots of annoying lemmas

A similar problem occurs when trying to rule out a contradictory case in a proof.
In order for Twelf to recognise that the case is vacuously covered, we must employ a lemma and use input-coverage checking in place of the output-coverage checking.

\section*{[Goals/Tasks/Method/Approach]}

The goal of this project is to investigate --- and attempt to solve --- the underlying problems related to output coverage checking in a setting such as Twelf.

[What should I say here?]

\section*{Learning Objectives}

\begin{itemize}
	\item Survey and summarise relevant techniques for analysing logic programs. [too vague?]
  \item Analyse the current state of coverage checking in Twelf and similar languages, and consider alternative approaches. [too specific?]
  \item Design a deductive system [or algorithm?] that facilitates improved coverage checking, and prove relevant properties about the system, e.g. soundness.
  \item Implement this system as proof-of-concept, possibly integrated in Twelf, and evaluate it as a solution to the problem.
\end{itemize}

\end{document}
