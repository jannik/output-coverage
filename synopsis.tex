\documentclass[12pt]{article}

\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx}

\usepackage{amsmath, amssymb}
\usepackage{mathtools}

\usepackage{bussproofs}

\newcommand{\ensurecommand}[1]{\providecommand{#1}{}\renewcommand{#1}}

\ensurecommand{\defi}{\Coloneqq}
\ensurecommand{\alt}{\;\; | \;\;}
\ensurecommand{\eval}[2]{\ensuremath{#1 \downarrow #2}}
\ensurecommand{\step}[2]{\ensuremath{#1 \rightarrow #2}}

\ensurecommand{\true}{\mathtt{true}}
\ensurecommand{\false}{\mathtt{false}}

\ensurecommand{\ninf}[1]{\AxiomC{#1}}
\ensurecommand{\uinf}[1]{\UnaryInfC{#1}}
\ensurecommand{\binf}[1]{\BinaryInfC{#1}}
\ensurecommand{\ax}[1]{\ninf{} \uinf{#1}}
\ensurecommand{\leftl}[1]{\LeftLabel{#1 \;}}
\ensurecommand{\rulename}{\textsc}

\begin{document}

\title{Synopsis: Output Coverage in Twelf}
\author{Jannik Gram}
\date{February 9, 2016}

\maketitle

\section*{Background}

In logic programming, functions are expressed as relations.
% And some relations are in fact total functions..

As part of the abstract syntax of a programming language, it is common to have truth values $t$ and boolean expressions $b$:
\begin{align*}
  t &\defi \true \alt \false \\
  b &\defi t \alt \neg{b} \alt \cdots
\end{align*}
And the following evaluation judgement gives a natural semantics to boolean expressions:

{ % judgement
\vspace{0.5cm}
\noindent \framebox{\eval{b}{t}}

\begin{prooftree}
  \leftl{\rulename{E-Const} :}
  \ax{\eval{t}{t}}
\end{prooftree}

\begin{prooftree}
  \ninf{\eval{b}{\true}}
  \leftl{\rulename{E-NegT} :}
  \uinf{\eval{\neg{b}}{\false}}
\end{prooftree}

\begin{prooftree}
  \ninf{\eval{b}{\false}}
  \leftl{\rulename{E-NegF} :}
  \uinf{\eval{\neg{b}}{\true}}
\end{prooftree}

\centering{$\vdots$}

\vspace{0.5cm}
}

This relation (as far as it is specified) is clearly a function, viewing $b$ as input and $t$ as output.
It is furthermore a total function, i.e. any expression $b$ evaluates to some value $t$.
If we omit one the rules for negation, however, the function is no longer total;
the premise of the remaining rule requires that $b$ evaluates to a specific truth value, but that is by no means a certainty.

In terms of logic programming, the output of a subgoal is not [what is correct to say?]
% it checks that the output of each premise of each constant can never fail to unify with an output that is actually produced.
This is the notion of \textit{output coverage}.

\section*{Problem}

If we formalise the relation above in e.g. LF, we might then like the Twelf system to be able to verify that it defines a total function.
However, as part of its totality checker Twelf checks output coverage --- and it does so for each rule in isolation.
This way it correctly identifies that the version with just a single of the above rules for negation does not define a total function.
On the other hand, it fails to identify that \rulename{E-NegT} and \rulename{E-NegF} together make the function total.
% That is, we are prevented from pattern matching on the output

The typical way around this problem in Twelf is to turn an output-coverage checking problem into an input-coverage checking problem.
That is, we essentially have to write a single general \rulename{E-Neg} rule that then uses an auxiliary negation judgement:

\begin{prooftree}
  \ninf{\eval{b}{t}}
  \ninf{\step{t}{t'}}
  \leftl{\rulename{E-Neg} :}
  \binf{\eval{\neg{b}}{t'}}
\end{prooftree}

{ % judgement
\vspace{0.5cm}
\noindent \framebox{\step{t}{t}}

\begin{prooftree}
  \leftl{\rulename{N-True} :}
  \ax{\step{\true}{\false}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{N-False} :}
  \ax{\step{\false}{\true}}
\end{prooftree}

\vspace{0.5cm}
}

Twelf will then be able to verify that the evaluation relation is a total function, but this comes at the cost of readability and extra work.
The problem is particularly present when proving meta-theorems about deductive systems and using totality checking as proof checking, which is after all what Twelf is designed for.
% i.e. lots of annoying lemmas
% mention also the related problem of contradictions

\section*{Approach}

[Goal of the project --- to look into and try to improve the situation.]

\section*{Learning Objectives}

[A few project-specific learning objectives.]

\end{document}