\documentclass[12pt]{article}

\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx}

\usepackage{fancyvrb} % for BVerbatim

\usepackage{amsmath, amssymb}
\usepackage{mathtools} % for Coloneqq

\usepackage{bussproofs}

\newcommand{\ensurecommand}[1]{\providecommand{#1}{}\renewcommand{#1}}

\ensurecommand{\defi}{\Coloneqq}
\ensurecommand{\alt}{\;\; | \;\;}
\ensurecommand{\eval}[2]{\ensuremath{#1 \downarrow #2}}
\ensurecommand{\step}[2]{\ensuremath{#1 \overset{\neg}{\rightarrow} #2}}

\ensurecommand{\true}{\mathtt{true}}
\ensurecommand{\false}{\mathtt{false}}

\ensurecommand{\ninf}[1]{\AxiomC{#1}}
\ensurecommand{\uinf}[1]{\UnaryInfC{#1}}
\ensurecommand{\binf}[1]{\BinaryInfC{#1}}
\ensurecommand{\ax}[1]{\ninf{} \uinf{#1}}
\ensurecommand{\leftl}[1]{\LeftLabel{#1 \;}}
\ensurecommand{\rulename}{\textsc}

\begin{document}

\title{Synopsis: Output Coverage in Twelf}
\author{Jannik Gram}
\date{February 10, 2016}

\maketitle

\section*{Background}

In logic programming, (partial) functions are expressed simply as relations that are moded, i.e. with input and output variables specified.
A moded relation is total, and so defines a total function, if for all possible input values there exist output values to satisfy the relation.
In constructive logic, a theorem of the form $\forall x{:}S . \, \exists y{:}T . \, p(x, y)$ corresponds to a total function mapping inputs of type $S$ to outputs of type $T$ --- producing for any $x$ a witness $y$ such that $p(x, y)$.
Hence it is important to be able to verify totality of moded relations in logic languages, and this is what e.g. the Twelf system~\cite{PfenningSchurmann99} is designed to do.

Theorem checking is the main motivation, but let us illustrate the problem with a simpler example.
As part of the abstract syntax of a programming language, it is common to have truth values $t$ and boolean expressions $b$:
\begin{align*}
  t &\defi \true \alt \false \\
  b &\defi t \alt \neg{b} \alt \cdots
\end{align*}
And the following evaluation judgement gives a natural semantics to such boolean expressions:

{ % judgement
\vspace{0.5cm}
\noindent \framebox{\eval{b}{t}}

\begin{prooftree}
  \leftl{\rulename{E-Const} :}
  \ax{\eval{t}{t}}
\end{prooftree}

\begin{prooftree}
  \ninf{\eval{b}{\true}}
  \leftl{\rulename{E-NegT} :}
  \uinf{\eval{\neg{b}}{\false}}
\end{prooftree}

\begin{prooftree}
  \ninf{\eval{b}{\false}}
  \leftl{\rulename{E-NegF} :}
  \uinf{\eval{\neg{b}}{\true}}
\end{prooftree}

\centering{$\vdots$}

\vspace{0.5cm}
}

This relation (as far as it is specified) is a function, viewing $b$ as input and $t$ as output.
And it is clearly a total function, i.e. any expression $b$ evaluates to some value $t$.
If we omit one of the rules for negation, however, the function is no longer total;
the premise of the remaining rule requires that $b$ evaluates to a specific truth value, but that is by no means a certainty.

The judgement can be formalised as a logic programming signature as follows (using Twelf syntax):
\begin{center}
\begin{BVerbatim}
eval : exp -> val -> type.

eval/const : eval (const T) T.

eval/neg-t : eval (neg B) false
              <- eval B true.

eval/neg-f : eval (neg B) true
              <- eval B false.
\end{BVerbatim}
\end{center}
Omitting the \texttt{eval/neg-f} rule, say, the output of the subgoal in \texttt{eval/neg-t} is not necessarily covered by any rules.
This introduces the notion of \textit{output coverage}.

\section*{Problem}

Having formalised the relation as above, we might then like the Twelf system to be able to verify that it defines a total function.
However, as part of its totality checker Twelf checks output coverage --- and it does so for each rule in isolation.
This way it correctly identifies that the version with just a single of the two rules for negation does not define a total function.
On the other hand, it fails to identify that \rulename{E-NegT} and \rulename{E-NegF} together make the function total.

The typical way around this problem in Twelf is to turn an output-coverage checking problem into an input-coverage checking problem.
That is, we essentially have to write a single general \rulename{E-Neg} rule that then uses an auxiliary negation judgement:

\begin{prooftree}
  \ninf{\eval{b}{t}}
  \ninf{\step{t}{t'}}
  \leftl{\rulename{E-Neg} :}
  \binf{\eval{\neg{b}}{t'}}
\end{prooftree}

{ % judgement
\vspace{0.5cm}
\noindent \framebox{\step{t}{t'}}

\begin{prooftree}
  \leftl{\rulename{N-True} :}
  \ax{\step{\true}{\false}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{N-False} :}
  \ax{\step{\false}{\true}}
\end{prooftree}

\vspace{0.5cm}
}

This is referred to as \textit{output factoring}.
Twelf will then be able to verify that the evaluation relation is a total function, but this comes at the cost of readability and extra work.
The problem is particularly present when proving meta-theorems about deductive systems and using totality checking as proof checking, which is after all what Twelf is most often used for.

A similar problem occurs when trying to rule out a contradictory case in a proof.
In order for Twelf to recognise that the case is vacuously covered, we must employ a lemma and use input coverage checking in place of the output coverage checking.

As an example, we can try to prove that evaluation is deterministic, i.e. \textit{if $\eval{b}{t}$ and $\eval{b}{t'}$ then $t = t'$}, by induction on the first evaluation derivation.
If one derivation ends in \rulename{E-NegT} and the other in \rulename{E-NegF}, by the induction hypothesis we get the contradiction $\true = \false$, and so the case is impossible.
Representing equality of truth values as a type family in Twelf, the contradiction is represented by having an inhabitant of an empty equality type.
But the output coverage checker does not notice this, and so we have to refer to a specialised lemma (with zero clauses!) that uses the contradiction to produce whatever we need for the proof case.

% mention third problem --- output freeness

\section*{Goals}

The overall goal of this project is to investigate --- and develop solutions for --- the problems related to output coverage checking in the following settings:

\begin{itemize}
	\item For pure Prolog.
  \item Possibly for a larger subset of Twelf, i.e. including one or more of:
    \begin{itemize}
      \item Dependent types.
      \item Higher-order data.
      \item Hereditary Harrop formulae.
    \end{itemize}
\end{itemize}

\section*{Approach}

% this section doesn't really fit in

A system that improves on solves output-coverage checking problems may take different forms.
One approach is to identify common patterns where factorisation might be needed, blindly factorise in all matching cases, and then hand over the resulting, longer program to Twelf's existing totality checker.
It is unclear whether this is feasible as a general solution.
Another approach is to perform the output coverage analysis outside of Twelf.
It is then necessary to prove at least soundness of the system, since the analysis needs to be trustworthy.

% note that it is unclear what the ``user interface'' should be
% also: may need to include mode checking in analysis (for void case)

\section*{Learning Objectives}

\begin{itemize}
	\item Survey and summarise relevant techniques for analysing logic programs in relation to totality and mode checking.
  \item Analyse shortcomings of the current state of coverage checking in Twelf and similar languages, and consider alternative approaches.
  \item Design a deductive system (or algorithm) that facilitates improved coverage checking, and prove relevant properties about the system, e.g. soundness.
  \item Implement this system as proof-of-concept, possibly integrated in Twelf, and evaluate it as a solution to the specified problem.
\end{itemize}

\begin{thebibliography}{9}

\bibitem{PfenningSchurmann99}
Frank Pfenning, Carsten Sch\"{u}rmann.
\textit{System Description: Twelf --- A Meta-Logical Framework for Deductive Systems}.
In \textit{Proceedings of the 16th International Conference on Automated Deduction}, pages 202-206, 1999.

\end{thebibliography}

\end{document}
